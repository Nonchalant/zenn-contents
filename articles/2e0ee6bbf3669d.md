---
title: "C#ã§MVVMã®ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ã‚’è‡ªå‹•ç”Ÿæˆã™ã‚‹"
emoji: "ğŸŒŸ"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: [csharp, ãƒ¡ã‚¿ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°, MVVM, ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°, ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ]
published: true
---

ã“ã®è¨˜äº‹ã¯[Applibot Advent Calendar 2024](https://qiita.com/advent-calendar/2024/applibot)ã®24æ—¥ç›®ã®è¨˜äº‹ã§ã™ã€‚

æ¥å¹´ã‹ã‚‰Unityã§ã‚²ãƒ¼ãƒ é–‹ç™ºã‚’å§‹ã‚ã‚‹ã®ã§ã€æ€¥ã„ã§å‹‰å¼·ä¸­ã®[äº•åŸ](https://x.com/nonchalant0303)ã§ã™ã€‚ã“ã‚Œã¾ã§ã¯iOSã‚¢ãƒ—ãƒªé–‹ç™ºã‚’ãƒ¡ã‚¤ãƒ³ã«æ¥­å‹™ã‚’è¡Œã£ã¦ã„ã¾ã—ãŸãŒã€Unityã§ã‚‚iOSã‚¢ãƒ—ãƒªé–‹ç™ºã®çŸ¥è¦‹ã‚’æ´»ã‹ã›ãªã„ã‹æ¤œè¨ã—ã¦ã„ã¾ã™ã€‚ä»Šå›ã¯ãã®ä¸€éƒ¨ã«ã¤ã„ã¦è§¦ã‚Œã¾ã™ã€‚

# iOSé–‹ç™ºã«ãŠã‘ã‚‹MVVM

ä»¥å‰ã«é–‹ç™ºã—ã¦ã„ãŸiOSã‚¢ãƒ—ãƒªã§ã¯ã€ŒMVVM + Clean Architectureã€ã‚’æ¡ç”¨ã—ã€å„ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’RxSwiftã§ç¹‹ã„ã§ã„ã¾ã—ãŸã€‚ã—ã‹ã—ã€ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ç´°ã‹ãåˆ†ã‘ã‚‹ã“ã¨ã§ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ãŒå¤šãç™ºç”Ÿã—ã¦ã—ã¾ã„ã¾ã—ãŸã€‚

```swift
import RxRelay
import RxSwift

protocol ViewModelType {
    var event1: Observable<Void> { get }
    var event2: Observable<Void> { get }
    ...
    var eventN: Observable<Void> { get }
}

// ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ã‚’å¤šæ•°å«ã‚€ViewModel
class ViewModel: ViewModelType {
    private let _event1 = PublishRelay<Void>()
    var event1: Observable<Void> { _event1.asObservable() }

    private let _event2 = PublishRelay<Void>()
    var event: Observable2<Void> { _event2.asObservable() }

    ...

    private let _eventN = PublishRelay<Void>()
    var eventN: Observable<Void> { _eventN.asObservable() }

    func doSomething() {
        _event1.accept(())
    }
}
```

Swiftã§ã¯propertyWrapperã¨ã„ã†æ©Ÿèƒ½ã‚’æ´»ç”¨ã—ã¦ã€ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ã‚’æ’é™¤ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

https://github.com/swiftlang/swift-evolution/blob/main/proposals/0258-property-wrappers.md

```swift
typealias PublishWrapper<T> = RelayWrapper<Observable<T>, T>

@propertyWrapper
struct RelayWrapper<Wrapped, Element> {

    let wrappedValue: Wrapped
    let accept: (Element) -> Void

    init(wrapped: Wrapped, accept: @escaping (Element) -> Void) {
        self.wrappedValue = wrapped
        self.accept = accept
    }
}

extension RelayWrapper where Wrapped == Observable<Element> {
    init() {
        let relay = PublishRelay<Element>()
        self.init(wrapped: relay.asObservable(), accept: { relay.accept($0) })
    }
}

// propertyWrapperã‚’æ´»ç”¨ã—ãŸViewModel
class ViewModel: ViewModelType {
    @PublishWrapper()
    var event1: Observable<Void>

    @PublishWrapper()
    var event: Observable2<Void>

    ...

    @PublishWrapper()
    var eventN: Observable<Void>
    
    func do() {
        _event1.accept(())
    }
}
```

# C#ã§MVVMã‚’å®Ÿè£…ã—ã¦ã¿ã‚‹

C#ã§ã‚‚iOSé–‹ç™ºã¨åŒæ§˜ã«ã€ŒMVVM + Clean Architectureã€ã‚’å®Ÿè£…ã—ã¦ã¿ã¾ã™ã€‚

```Csharp
using R3

interface IViewModel
{
    Observable<Unit> Event1 { get; }
    Observable<Unit> Event2 { get; }
    ...
    Observable<Unit> EventN { get; }
}

// ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ã‚’å¤šæ•°å«ã‚€ViewModel
class ViewModel: IViewModel
{
    private readonly Subject<Unit> _event1 = new();
    Observable<Unit> Event1 => _event1.AsObservable();
    
    private readonly Subject<Unit> _event2 = new();
    Observable<Unit> Event2 => _event2.AsObservable();

    ...

    private readonly Subject<Unit> _eventN = new();
    Observable<Unit> EventN => _eventN.AsObservable();
}
```

åŒæ§˜ã«ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ãŒå¤šæ•°ç”Ÿã¾ã‚Œã¦ã—ã¾ã†ã®ã§ã€C#ã«ãŠã„ã¦ã‚‚ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ã‚’æ’é™¤ã—ã¦ã„ãã¾ã™ã€‚æœ€åˆã¯Attributeã‚’æ´»ç”¨ã—ã¦å®Ÿç¾ã§ããªã„ã‹æ¤œè¨ã—ã¾ã—ãŸãŒã€Genericsã‚’æ´»ç”¨ã§ããªã‹ã£ãŸãŸã‚ã€ãƒ¡ã‚¿ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã§ã‚³ãƒ¼ãƒ‰ç”Ÿæˆã‚’è¡Œã†ã“ã¨ã«ã—ã¾ã—ãŸã€‚

ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãªã©ã¯ @amenone_games ã•ã‚“ã®ãƒ–ãƒ­ã‚°ãŒå‚è€ƒã«ãªã‚Šã¾ã—ãŸã€‚
https://qiita.com/amenone_games/items/762cbea245f95b212cfa

```Csharp
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.DotnetRuntime.Extensions;
using Microsoft.CodeAnalysis.Text;

namespace ObservableWrapper;

[Generator(LanguageNames.CSharp)]
public class SourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // è‡ªå‹•ç”Ÿæˆå¯¾è±¡ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«ä»˜ä¸ã™ã‚‹ObservableWrapperAttributeã®ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
        context.RegisterPostInitializationOutput(static x => SetAttribute(x));

        // ObservableWrapperAttributeãŒä»˜ä¸ã•ã‚ŒãŸãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å¯¾è±¡ã¨ã—ãŸã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
        var provider = context.SyntaxProvider.ForAttributeWithMetadataName
            (
                context,
                "ObservableWrapperGenerator.ObservableWrapperAttribute",
                static (node, _) => node is VariableDeclaratorSyntax,
                static (cont, _) => cont
            )
            .Combine(context.CompilationProvider);

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            static (sourceProductionContext, t) =>
            {
                var (compilation, list) = t;

                var typeMetas = new List<SubjectTypeMeta>();

                foreach (var (x, y) in list)
                {
                    var typeMeta = SubjectTypeMeta.TryCreate(x.TargetSymbol, x.TargetNode);
                    if (typeMeta != null) typeMetas.Add(typeMeta);
                }
                
                var generatedClassNames = new List<string>();

                foreach(var typeMeta in typeMetas)
                {
                    var fullClassName = typeMeta.GetFullClassName();
                    
                    if (generatedClassNames.Contains(fullClassName)) continue;
                    
                    var commonTypeMetas = typeMetas
                        .Where(x => x.GetFullClassName() == fullClassName)
                        .ToList();

                    var builder = new StringBuilder();
                    var fileName = SubjectEmit.Emit(builder, commonTypeMetas);

                    if (fileName != null)
                    {
                        // ãƒ¡ã‚¿ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã§å–å¾—ã—ãŸæƒ…å ±ã‚’å…ƒã«ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
                        sourceProductionContext.AddSource(
                            $"{fileName}.g.cs",
                            SourceText.From(builder.ToString(), Encoding.UTF8)
                        );
                        
                        generatedClassNames.Add(fullClassName);
                    }

                    builder.Clear();
                }
            });
    }

    // è‡ªå‹•ç”Ÿæˆå¯¾è±¡ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«ä»˜ä¸ã™ã‚‹ObservableWrapperAttributeã®ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
    private static void SetAttribute(IncrementalGeneratorPostInitializationContext context)
    { 
        const string attributeText = """
                                   using System;

                                   namespace ObservableWrapperGenerator
                                   {
                                      [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
                                      sealed class ObservableWrapperAttribute : Attribute {
                                          public ObservableWrapperAttribute() {}
                                      }
                                   }
                                   """;                
        context.AddSource
        (
            "ObservableWrapperAttribute.cs",
            SourceText.From(attributeText, Encoding.UTF8)
        );
    }
}

// ã‚³ãƒ¼ãƒ‰ç”Ÿæˆã®å¯¾è±¡
// ViewModel.cs
public partial class ViewModel: IViewModel
{
    @ObservableWrapper
    private readonly Subject<Unit> _event1 = new();
    
    @ObservableWrapper
    private readonly Subject<Unit> _event2 = new();

    ...

    @ObservableWrapper
    private readonly Subject<Unit> _eventN = new();
}

// ã‚³ãƒ¼ãƒ‰ç”Ÿæˆç‰©
// ViewModel.g.cs
public partial class VideModel
{
    public Observable<Unit> Event1 => _event1.AsObservable();
    public Observable<Unit> Event2 => _event2.AsObservable();
    ...
    public Observable<Unit> EventN => _event3.AsObservable();
}
```

ä»¥ä¸‹ã€ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã«ãªã‚Šã¾ã™ã€‚
https://github.com/Nonchalant/ObservableWrapper-CSharp

# ã¾ã¨ã‚

ãƒ¡ã‚¿ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’æ´»ç”¨ã™ã‚‹ã“ã¨ã§ã€ã‚³ãƒ¼ãƒ‰ã®æƒ…å ±ã‚’åŠ¹ç‡çš„ã«å–å¾—ã§ãã‚‹ãŸã‚ã€ã‚¢ã‚¤ãƒ‡ã‚¢æ¬¡ç¬¬ã§æ§˜ã€…ãªä½¿ã„é“ãŒã‚ã‚‹ã¨æ„Ÿã˜ã¾ã—ãŸã€‚ãŸã ã—ã€ç”Ÿæˆã™ã‚‹ã‚³ãƒ¼ãƒ‰ãŒå¢—ãˆã‚‹ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®ä½ä¸‹ãŒæ‡¸å¿µã•ã‚Œã‚‹ãŸã‚ã€ç´°ã‹ãªãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°ãŒå¿…è¦ã«ãªã‚‹ã¨æ€ã„ã¾ã™ã€‚ã“ã®è¨˜äº‹ãŒã‚³ãƒ¼ãƒ‰ç”Ÿæˆã«é–¢ã™ã‚‹å‚è€ƒã«ãªã‚Œã°å¹¸ã„ã§ã™ã€‚
