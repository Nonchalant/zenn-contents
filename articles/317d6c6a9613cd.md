---
title: "Combine Ã— propertyWrapperã§ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œãƒ»è³¼èª­ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å®šç¾©ã‚’ã¾ã¨ã‚ã‚‹"
emoji: "ğŸ¡"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: [Swift, Combile, propertyWrapper]
published: true
---

Swift 5.2

Combineã§ã¯ç¶™ç¶šçš„ã«ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ PassthroughSubjectã‚’æ´»ç”¨ã™ã‚‹ã“ã¨ãŒå¤šã„ãŒã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å…¬é–‹ã™ã‚‹ã¨ã‚¤ãƒ™ãƒ³ãƒˆã®è³¼èª­ã®ã¿ãªã‚‰ãšå¤–éƒ¨ã‹ã‚‰ã®ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œã‚‚å¯èƒ½ã«ãªã£ã¦ã—ã¾ã†ã€‚ã“ã‚Œã‚’å›é¿ã™ã‚‹ãŸã‚ã«PassthroughSubjectã‚’AnyPublisherã«å¤‰æ›ã—ã¦ã€ã‚¤ãƒ™ãƒ³ãƒˆè³¼èª­ã®ã¿å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”¨æ„ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚

```swift
import Combine

struct OrdinaryCombine {
 
    let subject: AnyPublisher<String, Never>
    private let _subject: PassthroughSubject<String, Never>

    init() {
        self.subject = _subject.eraseToAnyPublisher()
    }
  
    func print() {
        _subject.accept("Hello, world")
    }
}

var cancellables: [AnyCancellable] = []

let combine = OrdinaryCombine()

combine.subject
    .sink { value in
        print(value) // Hello, world
    }
    .store(in: &cancellables)

combine.print()
```

PassthroughSubject x AnyPublisherã“ã®æ–¹æ³•ã ã¨æ¯å›2ã¤ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å®šç¾©ã—ãªãã¦ã¯ãªã‚‰ãšã€ã¾ãŸé–¢é€£ãŒã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ã®ã¿è¨˜è¼‰ã•ã‚Œã¦ãŠã‚Šã€å‘½åã‚’æƒãˆã‚‹ã“ã¨ã§é–¢é€£ã‚’æ˜ç¢ºã«ã—ã¦å¯èª­æ€§ã‚’å‘ä¸Šã™ã‚‹ãªã©ã®å·¥å¤«ãŒæ±‚ã‚ã‚‰ã‚Œãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ã‚¹ãƒˆãŒä¸ŠãŒã£ã¦ã—ã¾ã†ã€‚

## RelayWrapper (Combine Ã— propertyWrapper)


```swift
import Combine

public typealias PublishWrapper<T> = RelayWrapper<AnyPublisher<T, Never>, T>

@propertyWrapper
public struct RelayWrapper<Wrapped, Element> {

    public let wrappedValue: Wrapped
    public let accept: (Element) -> Void

    init(wrapped: Wrapped, accept: @escaping (Element) -> Void) {
        self.wrappedValue = wrapped
        self.accept = accept
    }
}

public extension RelayWrapper where Wrapped == AnyPublisher<Element, Never> {
    init() {
        let relay = PassthroughSubject<Element, Never>()
        self.init(wrapped: relay.eraseToAnyPublisher(), accept: { relay.send($0) })
    }
}
```

[propertyWrapper](https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md)ã‚’æ´»ç”¨ã—ã¦å®šç¾©ã—ãŸRelayWrapperã‚’æ´»ç”¨ã™ã‚‹ã“ã¨ã§ã€å†…éƒ¨çš„ã«PassthroughSubjectã‚’ä¿æŒã—ã¦ã€å¤–éƒ¨ã«ã¯AnyPublisherã®ã¿ã‚’å…¬é–‹ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã«ãªã‚‹ã€‚å†…éƒ¨ã§ä¿æŒã—ã¦ã„ã‚‹PassthroughSubjectã¯RelayWrapperå‹ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒå®£è¨€ã•ã‚Œã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ã®ã¿ã§å‚ç…§å¯èƒ½ãªã®ã§ã€å¤–éƒ¨ã‹ã‚‰ã®ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œã¯å‡ºæ¥ãªã„ã€‚

```swift
import Combine

struct AdvancedCombine {

    @PublishWrapper()
    var subject: AnyPublisher<String, Never>

    func print() {
        _subject.accept("Hello, world")
    }
}

var cancellables: [AnyCancellable] = []

let combine = AdvancedCombine()

combine.subject
    .sink { value in
        print(value) // Hello, world
    }
    .store(in: &cancellables)

combine.print()
```

RelayWrapperã®æ´»ç”¨AdvancedCombineå†…ã§ã¯`_subject: RelayWrapper<AnyPublisher<String, Never>, String>`ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œãƒ»è³¼èª­ãŒå‡ºæ¥ã‚‹ãŒã€AdvancedCombineå¤–ã§ã¯`subject: AnyPublisher<String, Never>`ã®ã¿ã—ã‹ã‚¢ã‚¯ã‚»ã‚¹ã§ããšã‚¤ãƒ™ãƒ³ãƒˆè³¼èª­ã®ã¿ã—ã‹å‡ºæ¥ãªã„ã€‚ã¾ãŸã€ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œã¨ã‚¤ãƒ™ãƒ³ãƒˆè³¼èª­ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‘½åãŒãšã‚Œãšã«ãƒ¬ãƒ“ãƒ¥ãƒ¼ãªã©ã§å¯èª­æ€§ã‚’æ‹…ä¿ã™ã‚‹å¿…è¦ãŒãªããªã‚‹ã€‚

---

## (ãŠã¾ã‘) RxRelay + RxSwiftã¸ã®å¿œç”¨

RelayWrapperã‚’**PublishRelay â†’ Observable**, **BehaviorRelay â†’ RxProperty**ã«ã‚‚å¿œç”¨ã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã‚‹ã€‚

```swift
import RxRelay
import RxSwift

public typealias PublishWrapper<T> = RelayWrapper<Observable<T>, T>
public typealias BehaviorWrapper<T> = RelayWrapper<Property<T>, T>

@propertyWrapper
public struct RelayWrapper<Wrapped, Element> {

    public let wrappedValue: Wrapped

    public let accept: (Element) -> Void

    init(wrapped: Wrapped, accept: @escaping (Element) -> Void) {
        self.wrappedValue = wrapped
        self.accept = accept
    }
}

public extension RelayWrapper where Wrapped == Observable<Element> {
    init() {
        let relay = PublishRelay<Element>()
        self.init(wrapped: relay.asObservable(), accept: { relay.accept($0) })
    }
}

public extension RelayWrapper where Wrapped == Property<Element> {
    init(value: Element) {
        let relay = BehaviorRelay(value: value)
        self.init(wrapped: Property(relay), accept: { relay.accept($0) })
    }
}
```
